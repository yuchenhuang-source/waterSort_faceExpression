# 可玩广告开场卡顿 - 性能分析（排除资源加载）

在排除「资源加载」因素后，开场数秒内的卡顿主要来自以下**主线程同步工作**和**每帧开销**。

---

## 〇、点击交互卡顿（与静态展示无关）

**现象**：试管静态展示正常，但**点击/移动球时**卡顿。

**原因**：交互时有两段动画在 **onUpdate 里每帧调用完整 drawLiquid()**，而不是静态布局或 14 管创建：

1. **removeTopBall（选管后移球）**：300ms 内每帧执行 `drawLiquid()`（约 18 次 @60fps）。
2. **animateWaterRiseWithSplash（球落地/取消选中后水位上升）**：350ms 内每帧执行 `drawLiquid()`（约 21 次 @60fps）。

每次 `drawLiquid()` 都会：清空 Graphics、多次 fillRect、维护/创建/销毁 boundarySurfaceSprites、对多个 Sprite 做 setTintFill/setDisplaySize。在 60fps 下连续执行会造成明显主线程峰值。

**已做优化**：

- 在 **Tube** 中增加 `drawLiquidThrottled(33)`，在上述两处 tween 的 **onUpdate** 里改为调用节流版（约 30fps 重绘），**onComplete** 仍调用一次 `drawLiquid()` 保证最终状态。
- **Board.checkWinCondition** 中，将 `checkDeadlock()` 改为 `delayedCall(0, checkDeadlock)`，把 14×14 的死局扫描放到下一帧，避免与“球落地”回调在同一帧执行。

---

## 一、开场瞬间（Preloader create → Game create）

### 1. Preloader create() 中的同步工作

- **粒子纹理生成**：`make.graphics` + `fillCircle` + `generateTexture('particle_texture', 10, 10)`，量小，影响有限。
- **大量动画注册**：
  - 火焰：25 帧，`fire_animation`
  - 液体：5 个动画（`liquid_up` 约 10 帧、`liquid_still` 约 11 帧、`liquid_move` 约 23 帧、`liquid_drop` 约 6 帧、`liquid_splash` 约 19 帧），合计约 70 帧的 `anims.create` 全部在主线程同步执行，会占用一定时间。

### 2. 配置被重复请求与解析

- **Preloader**：`getOutputConfigAsync().then(() => this.scene.start('Game'))`，已请求并解析一次 output-config。
- **Game create()**：`await this.loadConfig()` 内部再次调用 `getOutputConfigAsync()`。
- 结果：配置被请求/解析两次，若解析或 I/O 有成本，会加重开场卡顿。建议：Preloader 解析后把结果通过场景数据或全局缓存传给 Game，Game 内直接复用，不再请求。

### 3. Board 构造时的重头工作（最易感知卡顿）

- **createTubes()**：创建 **14 个 Tube**，每个 Tube 构造函数内会：
  - 创建多张图片、容器、Graphics、遮罩、Sprite（液面、分界液面等）
  - 注册 **每帧** 回调：`scene.events.on('update', this.updateMaskPosition, this)`
- **loadDifficultyAndInitialize()**：  
  - 再次通过 `getOutputConfigValueAsync` 取 difficulty、emptyTubeCount  
  - 然后 **同步** 调用 `initializeBalls()`。

### 4. 谜题生成在主线程同步执行

- `initializeNormalBalls()` → `generatePuzzleWithAdapter()`。
- 内部打乱步数约为 `(200 + difficulty * 20) * shuffleMultiplier`（例如 200~400+ 步），包含大量数组操作与随机数，**全部在主线程同步执行**，会在开场造成几十到上百毫秒的明显卡顿。

### 5. 初始化球时：96 次 addBall + drawLiquid + checkSameColorHighlight

- 约 96 个球，分 12 个有球试管，每个球 `tube.addBall(ball, false)`。
- 每次 `addBall(ball, false)` 会：
  - 调用 `drawLiquid()`：重绘液体、边界、液面 Sprite（含可能创建 `boundarySurfaceSprites`）
  - 调用 `checkSameColorHighlight()`：内部有 **2～3 处 `console.log`**
- 结果：开场约 **96 次** drawLiquid + 96 次 checkSameColorHighlight，且每次高亮检查都会打 log，合计数百条 `console.log`。在生产环境/移动端，**console 非常耗性能**，会直接拉高主线程耗时，加重卡顿。

### 6. handleResize 在构造时同步执行

- Board 构造函数末尾：`this.handleResize(scene.scale.gameSize)`。
- 对 **14 个试管** 依次执行 `tube.updateSize(tubeWidth, tubeHeight, ballSize, ballSpacing)`。
- 每次 `updateSize` 会：
  - `maskGraphics.clear()` + `fillRoundedRect` 重绘遮罩
  - `updateMaskPosition()`
  - **`drawLiquid()`**：完整液体重算、液面/分界 Sprite 的创建与更新
- 14 次连续执行在同一帧内完成，主线程会有一段明显峰值，容易造成「首帧/首秒卡一下」的体感。

---

## 二、开场约 0.5 秒：引导手指出现

- `createHand()` 中有：`this.scene.time.delayedCall(500, () => this.showHint())`。
- 500ms 时执行 `showHint()` → **`findBestMove()`**：
  - 双重循环遍历 14×14 试管组合，对每对合法移动计算 `calculateMoveScore()`；
  - 内部还有多处 `console.log`（如「推荐移动」「所有可能移动」「完成试管 +100」等）。
- 在开场 0.5 秒时集中执行一次较重逻辑 + 大量 log，会形成**第二次可感知的卡顿或掉帧**。

---

## 三、每帧持续开销

### 1. 14 个试管的 updateMaskPosition 每帧执行

- 每个 Tube 在 `scene.events.on('update', this.updateMaskPosition, this)` 中每帧调用：
  - `getWorldTransformMatrix()`
  - `this.maskGraphics.setPosition(matrix.tx, matrix.ty)`、`setScale(matrix.scaleX, matrix.scaleY)`
- 共 **14 次** 矩阵计算与设置。若遮罩与试管同属一个显示树且试管位置/缩放只在 resize 或布局时变化，可以改为**仅在位置/尺寸变化时更新遮罩**（如在 `updateSize` 或 setPosition 后更新），而不是每帧更新，能减轻每帧负担。

### 2. Board 的 update()

- 每帧只做 `idleTimer += delta` 和一次判断，开销很小。
- 但当 5 秒无操作后触发 `showHint()` 时，会再次执行 `findBestMove()` + 大量 log，可能造成偶发卡顿。

---

## 四、总结：除资源加载外的主要性能消耗

| 类型           | 原因 |
|----------------|------|
| **主线程阻塞** | 谜题生成 `generatePuzzleWithAdapter` 在主线程同步执行（200+ 步打乱） |
| **主线程阻塞** | Board 构造时 14 次 `updateSize` → 14 次完整 `drawLiquid()` 连续执行 |
| **主线程阻塞** | 96 次 `addBall` 每次触发 `drawLiquid` + `checkSameColorHighlight` |
| **主线程阻塞** | 配置被重复请求/解析（Preloader + Game 各一次） |
| **Console 开销** | `checkSameColorHighlight` 在每次高亮检查时 2～3 条 log，初始化约 96 次 → 数百条 log；`findBestMove`/`calculateMoveScore` 等也有多条 log |
| **0.5 秒峰值**  | 500ms 时 `showHint()` → `findBestMove()` 双重循环 + 多处在热路径上的 log |
| **每帧开销**    | 14 个试管每帧执行 `updateMaskPosition`（矩阵 + 设置遮罩），可改为按需更新 |

---

## 五、优化建议（简要）

1. **去掉或条件化热路径上的 console.log**  
   尤其是：`Tube.checkSameColorHighlight`、`Board.findBestMove`/`calculateMoveScore`、以及初始化/每帧会触发的 log。生产构建可用 `if (import.meta.env.DEV)` 或统一日志工具包裹。

2. **配置只加载与解析一次**  
   Preloader 中解析 output-config 后，将结果写入全局/场景数据，Game 的 `loadConfig()` 直接读缓存，不再调用 `getOutputConfigAsync()`。

3. **遮罩按需更新**  
   仅在试管位置或尺寸变化时（如 `updateSize`、布局 setPosition）更新 `maskGraphics` 的位置与缩放，移除 `scene.events.on('update', this.updateMaskPosition)` 的每帧调用；若必须每帧更新，再保留并考虑只对「可见或发生变化的试管」更新。

4. **延后或稀释引导逻辑**  
   将 `delayedCall(500, showHint)` 延后（如 1～2 秒），或在 `showHint` 内用 `requestIdleCallback`/下一帧再执行 `findBestMove()`，避免在 0.5 秒时与其它初始化争抢主线程。

5. **谜题生成异步化或分帧**  
   将 `generatePuzzleWithAdapter()` 放到 Worker 中，或分多帧执行（例如每帧执行 N 步打乱），避免单帧长时间占用主线程。

6. **减少初始化时的 drawLiquid 次数**  
   若可行，先批量完成所有 `addBall(ball, false)` 的「数据结构」更新，最后对每个试管统一调用一次 `drawLiquid()`，而不是每个球加一次就画一次。

按上述顺序处理（尤其是 1、2、4 和 3）通常能明显减轻开场数秒内的卡顿感。
