# 开场无操作时的性能消耗（聚焦「用户未点击前」会执行的重逻辑）

以下按**时间顺序**列出：从游戏启动到用户第一次点击前，**一定会或大概率会执行**的、可能消耗性能的操作（不含资源加载本身）。

---

## 一、Preloader 场景 create() 内（Game 启动前，主线程同步）

在 `getOutputConfigAsync().then(() => this.scene.start('Game'))` 之前，以下**同步执行**，会阻塞到 Game 启动：

| 操作 | 位置 | 内容 |
|------|------|------|
| 粒子纹理 | Preloader.create | `make.graphics` → `fillCircle(5,5,5)` → `generateTexture('particle_texture', 10, 10)` → `destroy` |
| 火焰动画 | Preloader.create | 25 帧 `fire_00000`～`fire_00024` 组成 `fire_animation`，`anims.create`（25 帧、25fps、repeat -1） |
| 液体动画 | Preloader.create | `createLiquidAnimations()`：5 个动画共约 70 帧（liquid_up / still / move / drop / splash），5 次 `anims.create` |

**影响**：主线程一次性做完纹理生成 + 约 95 帧动画注册，再才进入 `getOutputConfigAsync().then`；若设备慢，会拉长「白屏/转场」到 Game 出现的时间。

---

## 二、Game 场景 create() 内

### 1. 配置再次请求/解析

- **位置**：`await this.loadConfig()` → `getOutputConfigAsync()`。
- **内容**：Preloader 里已调用过一次 `getOutputConfigAsync()`，Game 启动后又调用一次（解析/读缓存、buildLiquidColors 等）。
- **影响**：重复解析或重复逻辑，加重开场主线程或 I/O。

### 2. Board 构造（同步部分）

- **createTubes()**  
  - 创建 14 个 `Tube`，每个 Tube 构造函数内：多张图片、容器、Graphics、遮罩、液面 Sprite、`scene.events.on('update', this.updateMaskPosition, this)`。  
  - **影响**：14 个对象创建 + 14 个每帧 update 监听器注册。

- **loadDifficultyAndInitialize()**  
  - **未 await**，异步执行；Board 构造不会等它完成。

- **createHand()**  
  - 创建手型图、设置 scale、**`this.scene.time.delayedCall(500, () => this.showHint())`**。  
  - **影响**：开场约 **500ms 后**会执行一次 `showHint()`（见下文「四」）。

- **handleResize(scene.scale.gameSize)**  
  - 对 14 个试管依次 `tube.updateSize(...)`。  
  - 每次 `updateSize`：`maskGraphics.clear()`、`fillRoundedRect`、`updateMaskPosition()`、**`drawLiquid()`**、setSize、setInteractive 等。  
  - **此时试管尚无球**：`drawLiquid()` 内 `balls.length === 0 && removingBallColor === null && addingBallColor === null` 会 early return，液体重绘成本低，但 14 次 clear + fillRoundedRect + updateMaskPosition 仍会执行。

- **scene.events.on('update', this.update, this)**  
  - 每帧执行 Board.update（idleTimer += delta，5 秒后可能触发 showHint）。

**影响**：Board 出现后，**每帧**已有 14× updateMaskPosition + 1× Board.update；且约 500ms 后会触发一次 showHint。

---

## 三、loadDifficultyAndInitialize() 完成时（异步，通常开场 1 秒内）

该异步在 Board 构造时启动，**未 await**，完成时间取决于配置请求；完成后会**同步执行** `initializeBalls()`：

### 1. 再次读配置（可能走缓存）

- `getOutputConfigValueAsync('difficulty', 10)`、`getOutputConfigValueAsync('emptyTubeCount', 2)`。  
- 若与 Preloader/Game 的 getOutputConfigAsync 共用缓存，则主要是读内存；否则可能再次解析。

### 2. 谜题生成（主线程同步，重）

- **位置**：`initializeNormalBalls()` → `generatePuzzleWithAdapter(...)`。  
- **内容**：根据 difficulty、emptyTubeCount 算颜色与管数，调用 `createPuzzle`，打乱步数约 200～400+（如 baseShuffleSteps 200 + difficultyBonus），大量数组与随机数运算。  
- **影响**：单次可能几十到上百毫秒，**全部在主线程**，容易造成「开场 1 秒内」一次明显卡顿或掉帧。

### 3. 验证谜题

- `validatePuzzle(tubeContents)`：遍历试管与球做合法性检查。  
- 成本相对谜题生成小，但仍在同一帧内执行。

### 4. 96 次 addBall(ball, false)（主线程同步，重）

- **位置**：`initializeNormalBalls()` 内双重循环，对 12 管 × 每管 8 球共 96 次 `this.tubes[i].addBall(ball, false)`。  
- **每次 addBall(ball, false)**：  
  - 把球加入试管列表与容器、设位置、**`this.drawLiquid()`**、**`this.checkSameColorHighlight()`**。  
- **影响**：  
  - **96 次完整 drawLiquid()**：每次 clear、多段液体、boundaries、可能创建/调整 boundarySurfaceSprites、bringToTop、多 Sprite setTintFill/setDisplaySize 等。  
  - **96 次 checkSameColorHighlight()**：可能 setTexture、tween 高亮。  
  - 这一段在**无用户操作**下集中执行，是开场无操作时**最重的一段**之一。

---

## 四、开场后「无操作」下的定时与每帧逻辑

### 1. 每帧固定（从 Game 出现到用户点击前一直在跑）

- **14 × Tube.updateMaskPosition**：每帧对 14 个试管执行 `getWorldTransformMatrix()`、`maskGraphics.setPosition`/`setScale`。  
- **Board.update**：每帧 `idleTimer += delta`，若 `idleTimer > 5000` 且手未显示则 `showHint()`。  
- **影响**：与「二、2」叠加，即使用户不点击，每帧也有 14 次矩阵/遮罩更新；低端机若再叠加后面 500ms / 5s 的 showHint，容易在开场数秒内感到卡顿或掉帧。

### 2. 开场约 500ms：第一次 showHint()（无操作也会执行）

- **触发**：`createHand()` 里 `delayedCall(500, () => this.showHint())`。  
- **showHint()**：  
  - `findBestMove()`：双重循环遍历 14×14 试管组合，对每个合法移动调用 `calculateMoveScore(...)`（完成奖励、球数、纯度、空管惩罚等）。  
  - 若有最佳移动，再算手指位置、`fadeInHand()`、`startHandAnimation()` 等。  
- **影响**：**无操作也会在约 500ms 时执行一次** 14×14 的 findBestMove + 多次 calculateMoveScore，是开场无操作时一个明确的**主线程峰值**。

### 3. 开场 5 秒、10 秒、…：若手未显示则再次 showHint()

- **触发**：Board.update 里 `idleTimer > 5000 && hand && !hand.visible` 时再次 `showHint()`。  
- **影响**：每 5 秒无操作且手未显示时，会再跑一次 findBestMove，形成周期性的小峰值。

---

## 五、小结：开场无操作时的重逻辑（按发生顺序）

| 阶段 | 操作 | 是否「无操作也会执行」 | 主要成本 |
|------|------|------------------------|----------|
| Preloader create | 粒子纹理 + 火焰 25 帧 + 液体 5 动画约 70 帧 | ✅ | 主线程同步，阻塞到 Game 启动 |
| Game create | getOutputConfigAsync 再次调用 | ✅ | 重复解析/读配置 |
| Board 构造 | createTubes（14 管 + 14 个 update 监听） | ✅ | 对象与监听器数量 |
| Board 构造 | handleResize → 14× updateSize（此时无球，drawLiquid 早退） | ✅ | 14× 遮罩重绘 + updateMaskPosition |
| Board 构造 | delayedCall(500, showHint) 注册 | ✅ | 为 500ms 后峰值埋点 |
| 每帧 | 14× updateMaskPosition + Board.update | ✅ | 每帧 14 次矩阵/遮罩 + idleTimer |
| loadDifficultyAndInitialize 完成 | getOutputConfigValueAsync ×2（可能缓存） | ✅ | 配置读取 |
| 同上 | generatePuzzleWithAdapter + validatePuzzle | ✅ | **谜题生成 + 验证，主线程同步** |
| 同上 | 96× addBall(ball, false) → 96× drawLiquid + 96× checkSameColorHighlight | ✅ | **开场无操作下最重的一段** |
| 开场约 500ms | showHint() → findBestMove()（14×14 + calculateMoveScore） | ✅ | **无操作也会触发的明显峰值** |
| 开场 5s、10s、… | 若手未显示则再次 showHint() | ✅ | 周期性 findBestMove |

若要**优先优化「开场无操作」的卡顿**，可重点考虑：

1. **96× drawLiquid + 96× checkSameColorHighlight**：能否先批量把球和液体状态算好，再对每个试管**只做一次** drawLiquid / checkSameColorHighlight，或合并/节流。  
2. **generatePuzzleWithAdapter**：是否可放到 Worker、或分帧执行、或降低打乱步数。  
3. **500ms 时的 showHint → findBestMove**：是否可延后（如 1～2 秒）、或放到 requestIdleCallback/下一帧、或首次只做轻量「有无任意合法移动」而不做完整评分。  
4. **每帧 14× updateMaskPosition**：若遮罩只在 resize/布局变化时变，可改为按需更新，减少每帧固定成本。  
5. **Preloader 中动画/纹理**：若需进一步缩短「白屏」时间，可考虑减少首帧同步工作量（如液体动画延后创建或按需创建）。

以上均为「开场时无操作就会调用的消耗性能的操作」的梳理，未改任何代码。
