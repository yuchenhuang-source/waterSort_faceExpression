# 性能问题进一步分析（其他可能瓶颈）

在已做「drawLiquid 节流」和「checkDeadlock 延后」后，若卡顿仍存在，以下为其他可能的性能瓶颈分析（**仅分析，不改动代码**）。

---

## 一、每帧固定执行（与交互无关）

### 1. 14 个试管的 `updateMaskPosition` 每帧执行

- **位置**：`Tube` 构造函数中 `scene.events.on('update', this.updateMaskPosition, this)`。
- **每帧行为**：对 14 个试管各执行一次：
  - `this.getWorldTransformMatrix()`：从当前对象沿父链到根，计算世界变换矩阵；
  - `this.maskGraphics.setPosition(matrix.tx, matrix.ty)`、`setScale(matrix.scaleX, matrix.scaleY)`。
- **可能影响**：
  - 14 次矩阵计算/读取（若 Phaser 内部有缓存，则可能只是读缓存）；
  - 几何遮罩源（maskGraphics）每帧被改位置/缩放，渲染器可能每帧用新遮罩做裁剪，带来 14 次遮罩状态更新或 draw call 增加。
- **为何静态展示“看起来正常”**：静态时没有 tween、没有 drawLiquid 的节流调用，主线程负载较低；一旦点击触发大量 tween + 节流后的 drawLiquid，与这 14 次/帧的 updateMaskPosition 叠加，容易在弱设备上暴露卡顿。

### 2. Board 的 `update`

- **位置**：`Board` 中 `scene.events.on('update', this.update, this)`。
- **每帧行为**：`idleTimer += delta`，若超过 5 秒且手未显示则 `showHint()` → `findBestMove()`（14×14 遍历 + 评分）。
- **可能影响**：仅在 5 秒无操作时触发一次，不是点击瞬间的主因，但若刚好在 5 秒时点了一下，可能与 `findBestMove` 重叠造成一次卡顿。

---

## 二、`drawLiquid()` 内部的重逻辑（即使用节流仍会执行）

每次调用 `drawLiquid()`（包括节流后的 33ms 一次）都会做以下事，单次成本不低：

### 1. 分配与数组操作

- `const boundaries: Array<{ y: number; color: BallColor }> = [];`：每次新建数组。
- `ballsForLiquid = this._topBallFloating && ... ? this.balls.slice(0, -1) : this.balls`：在顶球悬浮或正在加入液体时，每次 `slice(0, -1)` 分配新数组。
- 多次 `boundaries.push(...)`。
- **影响**：在 30fps 节流下，单管液体动画期间约 10 次/秒 × 多管可能同时动画 = 每秒数十次小分配，可能加剧 GC 频率与暂停。

### 2. 可能创建/销毁 GameObject（热路径）

- `while (this.boundarySurfaceSprites.length < boundaries.length)`：**不足时** `this.scene.add.sprite(...)`、`this.liquidContainer.add(sprite)`、`sprite.setMask(this.liquidMask)` 并 push 到数组。
- `while (this.boundarySurfaceSprites.length > boundaries.length)`：**多余时** `this.boundarySurfaceSprites.pop()` 且 `sprite.destroy()`。
- **影响**：分界数量随球颜色分布变化（例如从 2 段变 3 段再变回 2 段），会在一次移动过程中多次创建/销毁 Sprite，创建/销毁和加入显示列表、遮罩，成本较高，且可能触发引擎内部批量更新或脏标记扩散。

### 3. 显示列表重排

- `this.liquidContainer.bringToTop(this.surfaceSprite)`：在「有顶部液面」时**每次** drawLiquid 都执行。
- `this.liquidContainer.bringToTop(this.addingBlockBottomSurfaceSprite)`：在「有正在加入的块且非归位」时每次执行。
- **影响**：`bringToTop` 会调整子对象顺序，Phaser 的显示列表重排可能触发排序或脏区域更新；节流后仍约 30 次/秒/管，多管同时动画时成倍增加。

### 4. 重复的纹理存在检查

- `this.scene.textures.exists('liquid_surface')` 在 `drawLiquid()` 内出现**两次**（约 370 行与 455 行）。
- **影响**：单次成本小，但属于可避免的重复调用。

### 5. 大量 Sprite 属性更新

- 对顶部液面、每个分界液面、addingBlockBottomSurfaceSprite：`setVisible`、`setPosition`、`setTintFill`、`setDisplaySize`，且多次访问 `frame?.width`、`sprite.width` 等。
- **影响**：分界多时（例如 5–7 段）单次 drawLiquid 要更新 10+ 个 Sprite 的多种属性，可能带来批量脏标记和渲染更新。

---

## 三、多球移动时的调用集中（tryMoveBall）

### 1. 源试管上连续 3 次「removeBall + updateLiquidDisplay」

- 多球（如 3 个）移动时，每个球的 rise tween 的 `onStart` 里：`source.removeBall(ball)`、`source.updateLiquidDisplay()`。
- `removeBall` 内部：`this.drawLiquid()`、`this.checkSameColorHighlight()`。
- `updateLiquidDisplay()` 即 `this.drawLiquid()`。
- **结果**：约 0ms、100ms、200ms 处，源试管**连续 3 次**各执行 2 次 drawLiquid + 1 次 checkSameColorHighlight，即 6 次 drawLiquid + 3 次 checkSameColorHighlight 在约 200ms 内完成。
- **影响**：短时间内对同一试管多次完整重绘液体 + 高亮检查，容易在同一帧或相邻几帧内造成明显主线程峰值。

### 2. 目标试管上 3 段连续的水位上升动画

- 每个球落地的 `onComplete` 里调用 `target.animateWaterRiseWithSplash(...)`，3 球即 3 段**顺序**的水位上升（每段 350ms）。
- 每段内 onUpdate 使用 `drawLiquidThrottled(33)`，即约每 33ms 一次 drawLiquid。
- **结果**：约 1 秒内目标试管上约 30 次 drawLiquid，且每段动画还会创建/维护 splashSprite、可能改变 boundarySurfaceSprites 数量。
- **影响**：与「二」中 drawLiquid 内部成本叠加（分配、可能创建/销毁 Sprite、bringToTop、多 Sprite 更新），容易在移动过程中持续占用主线程。

### 3. 每次球落地后的 checkCompletionAndWin

- `delayedCall(0, checkCompletionAndWin)` 中：`target.checkCompletion()`、`target.checkSameColorHighlight()`、`source.checkSameColorHighlight()`、`this.checkWinCondition()`（内部已延后 `checkDeadlock`）。
- **影响**：同一帧内两次 `checkSameColorHighlight`，若触发高亮切换会执行 `setTexture`（见下节）。

---

## 四、同色高亮与纹理切换

### checkSameColorHighlight → showSameColorHighlight

- 会执行：`this.highlightBodyImage.setTexture(\`highlight_${color}_body\`)`、`this.highlightMouthImage.setTexture(\`highlight_${color}_mouth\`)`。
- **影响**：WebGL 下切换纹理容易打断批处理，增加 draw call；一次移动结束会对 source、target 各做一次高亮检查，若两者都需更新高亮则最多 4 次纹理切换（2 管 × 2 张图），在移动完成瞬间可能造成一小段卡顿。

---

## 五、动画与精灵数量

### 1. 液体球精灵动画

- 移动中：每个「在空中」的球有一个 `liquidSprite` 播放 `liquid_move`（约 23 帧、30fps、循环）。
- 悬浮：选中管的顶球播放 `liquid_still`（约 11 帧、20fps、yoyo）。
- **影响**：3 球同时移动 = 3 个 liquid_move 同时更新；若引擎按精灵/动画逐帧更新，会有一定每帧成本。

### 2. 水花与临时 Sprite

- `playSplashAtSurface` / 水位上升中的 splashSprite：创建 Sprite、播放 `liquid_splash`（约 19 帧）、onComplete 时 destroy。
- 一次移动可能多次水花（源管液面、目标管水位上升），存在多 Sprite 同时播动画和短生命周期创建/销毁。

### 3. 火焰动画（完成管）

- 完成管上的蜡烛有 `fire_animation`（25 帧、25fps、循环）。若已完成管较多，会有多个火焰动画同时跑。
- **影响**：相对点击路径可能次要，但在低端机上多动画叠加仍有成本。

---

## 六、Tween 数量与结构

- 一次 3 球移动：每球有「rise → arcX + arcY（嵌套）→ drop（内部再嵌套）」的链式 tween，且每段都有 onStart/onComplete。
- **影响**：Phaser 的 TweenManager 每帧要更新大量 tween 的状态与回调；嵌套多、回调多时，单帧内可能执行多次 onComplete/onStart，与 drawLiquid、checkSameColorHighlight 等挤在同一帧，放大主线程峰值。

---

## 七、音效

- 每次点击：`this.scene.sound.play('点击')`。
- 每个球落地：`this.sound.play('落下')`；多球移动时可能短时间多次「落下」。
- **影响**：若音效未预解码或解码在主线程，首次播放或短时间多次播放可能造成卡顿；可观察去掉/注释音效后卡顿是否减轻。

---

## 八、小结：其他可能瓶颈（按优先级粗排）

| 类别           | 内容 |
|----------------|------|
| **每帧固定**   | 14× updateMaskPosition（矩阵 + 遮罩更新），与点击时的 tween + drawLiquid 叠加。 |
| **drawLiquid** | 内部：boundaries/ballsForLiquid 分配、可能创建/销毁 boundarySurfaceSprites、bringToTop×2、textures.exists×2、大量 setTintFill/setDisplaySize。 |
| **多球移动**  | 源管短时间 6 次 drawLiquid + 3 次 checkSameColorHighlight；目标管约 1 秒内约 30 次 drawLiquid（节流后）。 |
| **高亮/纹理** | checkSameColorHighlight 导致 setTexture，可能打断批处理、增加 draw call。 |
| **分配/GC**   | drawLiquid 每次分配数组、可能创建/销毁 Sprite，频繁时增加 GC 压力。 |
| **Tween**     | 多球移动时嵌套 tween 与回调多，单帧内多次完成/启动，加重主线程峰值。 |
| **音效**      | 点击/落下音效若未预解码或主线程解码，可能造成瞬时卡顿。 |

建议在真机或低端设备上，按上述顺序逐项做「开关式」测试（例如注释掉 updateMaskPosition 的注册、或暂时关闭高亮、或关闭音效），观察卡顿是否明显变化，以确认哪一类是当前主要瓶颈，再针对性优化（例如遮罩按需更新、减少 drawLiquid 内分配与 create/destroy、高亮合并或延迟、音效预解码等）。
